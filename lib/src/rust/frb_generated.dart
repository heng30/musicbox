// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bilibili.dart';
import 'api/bilibili/bilibili.dart';
import 'api/data.dart';
import 'api/data/bilibili.dart';
import 'api/log.dart';
import 'api/lyric.dart';
import 'api/msg_center.dart';
import 'api/util.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.1.0';

  @override
  int get rustContentHash => -1172591305;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_musicbox',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiInitApp();

  Stream<ProgressData> crateApiBilibiliBvDownloadAudioByIdWithCallback(
      {required String id,
      required PlatformInt64 cid,
      required String downloadPath});

  Future<void> crateApiBilibiliBvDownloadPic(
      {required String url, required String downloadPath});

  Future<List<String>> crateApiBilibiliBvFetchIds(
      {required String keyword, required BigInt maxIdCount});

  Future<InfoData> crateApiBilibiliBvVideoInfo({required String bvid});

  String crateApiBilibiliBvWatchUrl({required String id});

  Future<List<String>> crateApiBilibiliBilibiliClientAudioUrls(
      {required Client that, required String bvid, required PlatformInt64 cid});

  Future<void> crateApiBilibiliBilibiliClientDownload(
      {required Client that,
      required String url,
      required String filePath,
      SenderProgressData? channel});

  Future<List<String>> crateApiBilibiliBilibiliClientFetchIds(
      {required Client that,
      required String keyword,
      required BigInt maxIdCount});

  Future<BvInfo> crateApiBilibiliBilibiliClientInfo(
      {required Client that, required String bvid});

  Future<Client> crateApiBilibiliBilibiliClientNew();

  Future<Uint8List> crateApiBilibiliBilibiliClientRequestPic(
      {required Client that, required String url});

  Future<VideoUrl> crateApiBilibiliBilibiliClientVideoUrl(
      {required Client that,
      required String bvid,
      required PlatformInt64 cid,
      required PlatformInt64 fnval,
      required VideoQuality videoQuality});

  Future<InfoData> crateApiDataInfoDataDefault();

  Future<ProgressData> crateApiDataProgressDataDefault();

  Future<Audio> crateApiDataBilibiliAudioDefault();

  Future<BvInfo> crateApiDataBilibiliBvInfoDefault();

  Future<Dash> crateApiDataBilibiliDashDefault();

  Future<DescV2> crateApiDataBilibiliDescV2Default();

  Future<Dimension> crateApiDataBilibiliDimensionDefault();

  Future<Durl> crateApiDataBilibiliDurlDefault();

  Future<Owner> crateApiDataBilibiliOwnerDefault();

  Future<Page> crateApiDataBilibiliPageDefault();

  Future<Rights> crateApiDataBilibiliRightsDefault();

  Future<SegmentBase> crateApiDataBilibiliSegmentBaseDefault();

  Future<Stat> crateApiDataBilibiliStatDefault();

  Future<SupportFormat> crateApiDataBilibiliSupportFormatDefault();

  Future<Video> crateApiDataBilibiliVideoDefault();

  Future<VideoQuality> crateApiDataBilibiliVideoQualityDefault();

  Future<VideoUrl> crateApiDataBilibiliVideoUrlDefault();

  Future<void> crateApiLogInit();

  Future<void> crateApiLogInitLogger();

  Future<String> crateApiLyricGetLyric({required String token});

  Future<void> crateApiLyricSaveLyric(
      {required String text, required String path});

  Future<List<SearchLyricItem>> crateApiLyricSearchLyric(
      {required String keyword});

  Future<SearchLyricItem> crateApiLyricSearchLyricItemDefault();

  Stream<MsgItem> crateApiMsgCenterMsgCenterInit();

  Future<void> crateApiMsgCenterSend({required MsgItem item});

  Future<void> crateApiUtilCreateDirAll({required String dir});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Client;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Client;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SenderProgressData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SenderProgressData;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SenderProgressDataPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Stream<ProgressData> crateApiBilibiliBvDownloadAudioByIdWithCallback(
      {required String id,
      required PlatformInt64 cid,
      required String downloadPath}) {
    final sink = RustStreamSink<ProgressData>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_progress_data_Sse(sink, serializer);
        sse_encode_String(id, serializer);
        sse_encode_i_64(cid, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBvDownloadAudioByIdWithCallbackConstMeta,
      argValues: [sink, id, cid, downloadPath],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiBilibiliBvDownloadAudioByIdWithCallbackConstMeta =>
      const TaskConstMeta(
        debugName: "bv_download_audio_by_id_with_callback",
        argNames: ["sink", "id", "cid", "downloadPath"],
      );

  @override
  Future<void> crateApiBilibiliBvDownloadPic(
      {required String url, required String downloadPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(url, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBvDownloadPicConstMeta,
      argValues: [url, downloadPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBvDownloadPicConstMeta =>
      const TaskConstMeta(
        debugName: "bv_download_pic",
        argNames: ["url", "downloadPath"],
      );

  @override
  Future<List<String>> crateApiBilibiliBvFetchIds(
      {required String keyword, required BigInt maxIdCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(keyword, serializer);
        sse_encode_usize(maxIdCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBvFetchIdsConstMeta,
      argValues: [keyword, maxIdCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBvFetchIdsConstMeta => const TaskConstMeta(
        debugName: "bv_fetch_ids",
        argNames: ["keyword", "maxIdCount"],
      );

  @override
  Future<InfoData> crateApiBilibiliBvVideoInfo({required String bvid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(bvid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_info_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBvVideoInfoConstMeta,
      argValues: [bvid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBvVideoInfoConstMeta =>
      const TaskConstMeta(
        debugName: "bv_video_info",
        argNames: ["bvid"],
      );

  @override
  String crateApiBilibiliBvWatchUrl({required String id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBilibiliBvWatchUrlConstMeta,
      argValues: [id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBvWatchUrlConstMeta => const TaskConstMeta(
        debugName: "bv_watch_url",
        argNames: ["id"],
      );

  @override
  Future<List<String>> crateApiBilibiliBilibiliClientAudioUrls(
      {required Client that,
      required String bvid,
      required PlatformInt64 cid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(bvid, serializer);
        sse_encode_i_64(cid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientAudioUrlsConstMeta,
      argValues: [that, bvid, cid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientAudioUrlsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_audio_urls",
        argNames: ["that", "bvid", "cid"],
      );

  @override
  Future<void> crateApiBilibiliBilibiliClientDownload(
      {required Client that,
      required String url,
      required String filePath,
      SenderProgressData? channel}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(url, serializer);
        sse_encode_String(filePath, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
            channel, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientDownloadConstMeta,
      argValues: [that, url, filePath, channel],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientDownloadConstMeta =>
      const TaskConstMeta(
        debugName: "Client_download",
        argNames: ["that", "url", "filePath", "channel"],
      );

  @override
  Future<List<String>> crateApiBilibiliBilibiliClientFetchIds(
      {required Client that,
      required String keyword,
      required BigInt maxIdCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(keyword, serializer);
        sse_encode_usize(maxIdCount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientFetchIdsConstMeta,
      argValues: [that, keyword, maxIdCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientFetchIdsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_fetch_ids",
        argNames: ["that", "keyword", "maxIdCount"],
      );

  @override
  Future<BvInfo> crateApiBilibiliBilibiliClientInfo(
      {required Client that, required String bvid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(bvid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bv_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientInfoConstMeta,
      argValues: [that, bvid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientInfoConstMeta =>
      const TaskConstMeta(
        debugName: "Client_info",
        argNames: ["that", "bvid"],
      );

  @override
  Future<Client> crateApiBilibiliBilibiliClientNew() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientNewConstMeta =>
      const TaskConstMeta(
        debugName: "Client_new",
        argNames: [],
      );

  @override
  Future<Uint8List> crateApiBilibiliBilibiliClientRequestPic(
      {required Client that, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientRequestPicConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientRequestPicConstMeta =>
      const TaskConstMeta(
        debugName: "Client_request_pic",
        argNames: ["that", "url"],
      );

  @override
  Future<VideoUrl> crateApiBilibiliBilibiliClientVideoUrl(
      {required Client that,
      required String bvid,
      required PlatformInt64 cid,
      required PlatformInt64 fnval,
      required VideoQuality videoQuality}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(bvid, serializer);
        sse_encode_i_64(cid, serializer);
        sse_encode_i_64(fnval, serializer);
        sse_encode_box_autoadd_video_quality(videoQuality, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_video_url,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiBilibiliBilibiliClientVideoUrlConstMeta,
      argValues: [that, bvid, cid, fnval, videoQuality],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBilibiliBilibiliClientVideoUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Client_video_url",
        argNames: ["that", "bvid", "cid", "fnval", "videoQuality"],
      );

  @override
  Future<InfoData> crateApiDataInfoDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_info_data,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataInfoDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataInfoDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "info_data_default",
        argNames: [],
      );

  @override
  Future<ProgressData> crateApiDataProgressDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_progress_data,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataProgressDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataProgressDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "progress_data_default",
        argNames: [],
      );

  @override
  Future<Audio> crateApiDataBilibiliAudioDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_audio,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliAudioDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliAudioDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "audio_default",
        argNames: [],
      );

  @override
  Future<BvInfo> crateApiDataBilibiliBvInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bv_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliBvInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliBvInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "bv_info_default",
        argNames: [],
      );

  @override
  Future<Dash> crateApiDataBilibiliDashDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_dash,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliDashDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliDashDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "dash_default",
        argNames: [],
      );

  @override
  Future<DescV2> crateApiDataBilibiliDescV2Default() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_desc_v_2,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliDescV2DefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliDescV2DefaultConstMeta =>
      const TaskConstMeta(
        debugName: "desc_v_2_default",
        argNames: [],
      );

  @override
  Future<Dimension> crateApiDataBilibiliDimensionDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_dimension,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliDimensionDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliDimensionDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "dimension_default",
        argNames: [],
      );

  @override
  Future<Durl> crateApiDataBilibiliDurlDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_durl,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliDurlDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliDurlDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "durl_default",
        argNames: [],
      );

  @override
  Future<Owner> crateApiDataBilibiliOwnerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_owner,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliOwnerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliOwnerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "owner_default",
        argNames: [],
      );

  @override
  Future<Page> crateApiDataBilibiliPageDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_page,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliPageDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliPageDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "page_default",
        argNames: [],
      );

  @override
  Future<Rights> crateApiDataBilibiliRightsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_rights,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliRightsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliRightsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "rights_default",
        argNames: [],
      );

  @override
  Future<SegmentBase> crateApiDataBilibiliSegmentBaseDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_segment_base,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliSegmentBaseDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliSegmentBaseDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "segment_base_default",
        argNames: [],
      );

  @override
  Future<Stat> crateApiDataBilibiliStatDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_stat,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliStatDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliStatDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "stat_default",
        argNames: [],
      );

  @override
  Future<SupportFormat> crateApiDataBilibiliSupportFormatDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_support_format,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliSupportFormatDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliSupportFormatDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "support_format_default",
        argNames: [],
      );

  @override
  Future<Video> crateApiDataBilibiliVideoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_video,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliVideoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliVideoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "video_default",
        argNames: [],
      );

  @override
  Future<VideoQuality> crateApiDataBilibiliVideoQualityDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_video_quality,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliVideoQualityDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliVideoQualityDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "video_quality_default",
        argNames: [],
      );

  @override
  Future<VideoUrl> crateApiDataBilibiliVideoUrlDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_video_url,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDataBilibiliVideoUrlDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDataBilibiliVideoUrlDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "video_url_default",
        argNames: [],
      );

  @override
  Future<void> crateApiLogInit() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLogInitConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLogInitConstMeta => const TaskConstMeta(
        debugName: "init",
        argNames: [],
      );

  @override
  Future<void> crateApiLogInitLogger() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLogInitLoggerConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLogInitLoggerConstMeta => const TaskConstMeta(
        debugName: "init_logger",
        argNames: [],
      );

  @override
  Future<String> crateApiLyricGetLyric({required String token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(token, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiLyricGetLyricConstMeta,
      argValues: [token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLyricGetLyricConstMeta => const TaskConstMeta(
        debugName: "get_lyric",
        argNames: ["token"],
      );

  @override
  Future<void> crateApiLyricSaveLyric(
      {required String text, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(text, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiLyricSaveLyricConstMeta,
      argValues: [text, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLyricSaveLyricConstMeta => const TaskConstMeta(
        debugName: "save_lyric",
        argNames: ["text", "path"],
      );

  @override
  Future<List<SearchLyricItem>> crateApiLyricSearchLyric(
      {required String keyword}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(keyword, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_search_lyric_item,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiLyricSearchLyricConstMeta,
      argValues: [keyword],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLyricSearchLyricConstMeta => const TaskConstMeta(
        debugName: "search_lyric",
        argNames: ["keyword"],
      );

  @override
  Future<SearchLyricItem> crateApiLyricSearchLyricItemDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_search_lyric_item,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLyricSearchLyricItemDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLyricSearchLyricItemDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "search_lyric_item_default",
        argNames: [],
      );

  @override
  Stream<MsgItem> crateApiMsgCenterMsgCenterInit() {
    final sink = RustStreamSink<MsgItem>();
    unawaited(handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_StreamSink_msg_item_Sse(sink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMsgCenterMsgCenterInitConstMeta,
      argValues: [sink],
      apiImpl: this,
    )));
    return sink.stream;
  }

  TaskConstMeta get kCrateApiMsgCenterMsgCenterInitConstMeta =>
      const TaskConstMeta(
        debugName: "msg_center_init",
        argNames: ["sink"],
      );

  @override
  Future<void> crateApiMsgCenterSend({required MsgItem item}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_msg_item(item, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiMsgCenterSendConstMeta,
      argValues: [item],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiMsgCenterSendConstMeta => const TaskConstMeta(
        debugName: "send",
        argNames: ["item"],
      );

  @override
  Future<void> crateApiUtilCreateDirAll({required String dir}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(dir, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiUtilCreateDirAllConstMeta,
      argValues: [dir],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUtilCreateDirAllConstMeta => const TaskConstMeta(
        debugName: "create_dir_all",
        argNames: ["dir"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Client => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Client => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SenderProgressData => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SenderProgressData => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Client
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SenderProgressData
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SenderProgressDataImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SenderProgressData
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SenderProgressDataImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RustStreamSink<MsgItem> dco_decode_StreamSink_msg_item_Sse(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  RustStreamSink<ProgressData> dco_decode_StreamSink_progress_data_Sse(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Audio dco_decode_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 17)
      throw Exception('unexpected arr length: expect 17 but see ${arr.length}');
    return Audio(
      id: dco_decode_i_64(arr[0]),
      baseUrl: dco_decode_String(arr[1]),
      backupUrl: dco_decode_list_String(arr[2]),
      backupUrl2: dco_decode_list_String(arr[3]),
      bandwidth: dco_decode_i_64(arr[4]),
      mimeType: dco_decode_String(arr[5]),
      mimeType2: dco_decode_String(arr[6]),
      codecs: dco_decode_String(arr[7]),
      width: dco_decode_i_64(arr[8]),
      height: dco_decode_i_64(arr[9]),
      frameRate: dco_decode_String(arr[10]),
      frameRate2: dco_decode_String(arr[11]),
      sar: dco_decode_String(arr[12]),
      startWithSap: dco_decode_i_64(arr[13]),
      startWithSap2: dco_decode_i_64(arr[14]),
      segmentBase: dco_decode_segment_base(arr[15]),
      codecid: dco_decode_i_64(arr[16]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  SenderProgressData
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
        raw);
  }

  @protected
  MsgItem dco_decode_box_autoadd_msg_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_msg_item(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  VideoQuality dco_decode_box_autoadd_video_quality(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_video_quality(raw);
  }

  @protected
  BvInfo dco_decode_bv_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 20)
      throw Exception('unexpected arr length: expect 20 but see ${arr.length}');
    return BvInfo(
      bvid: dco_decode_String(arr[0]),
      aid: dco_decode_i_64(arr[1]),
      videos: dco_decode_i_64(arr[2]),
      tid: dco_decode_i_64(arr[3]),
      copyright: dco_decode_i_64(arr[4]),
      pic: dco_decode_String(arr[5]),
      title: dco_decode_String(arr[6]),
      ctime: dco_decode_i_64(arr[7]),
      desc: dco_decode_String(arr[8]),
      descV2: dco_decode_list_desc_v_2(arr[9]),
      rights: dco_decode_rights(arr[10]),
      owner: dco_decode_owner(arr[11]),
      stat: dco_decode_stat(arr[12]),
      state: dco_decode_i_64(arr[13]),
      duration: dco_decode_i_64(arr[14]),
      dynamic_: dco_decode_String(arr[15]),
      cid: dco_decode_i_64(arr[16]),
      dimension: dco_decode_dimension(arr[17]),
      noCache: dco_decode_bool(arr[18]),
      pages: dco_decode_list_page(arr[19]),
    );
  }

  @protected
  Dash dco_decode_dash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Dash(
      duration: dco_decode_i_64(arr[0]),
      minBufferTime: dco_decode_f_64(arr[1]),
      minBufferTime2: dco_decode_f_64(arr[2]),
      video: dco_decode_list_video(arr[3]),
      audio: dco_decode_list_audio(arr[4]),
    );
  }

  @protected
  DescV2 dco_decode_desc_v_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DescV2(
      rawText: dco_decode_String(arr[0]),
      descType: dco_decode_i_64(arr[1]),
      bizId: dco_decode_i_64(arr[2]),
      rights: dco_decode_rights(arr[3]),
      owner: dco_decode_owner(arr[4]),
      stat: dco_decode_stat(arr[5]),
    );
  }

  @protected
  Dimension dco_decode_dimension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Dimension(
      width: dco_decode_i_64(arr[0]),
      height: dco_decode_i_64(arr[1]),
      rotate: dco_decode_i_64(arr[2]),
    );
  }

  @protected
  Durl dco_decode_durl(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Durl(
      order: dco_decode_i_64(arr[0]),
      length: dco_decode_i_64(arr[1]),
      size: dco_decode_i_64(arr[2]),
      ahead: dco_decode_String(arr[3]),
      vhead: dco_decode_String(arr[4]),
      url: dco_decode_String(arr[5]),
      backupUrl: dco_decode_list_String(arr[6]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  InfoData dco_decode_info_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return InfoData(
      title: dco_decode_String(arr[0]),
      author: dco_decode_String(arr[1]),
      videoId: dco_decode_String(arr[2]),
      shortDescription: dco_decode_String(arr[3]),
      viewCount: dco_decode_u_64(arr[4]),
      lengthSeconds: dco_decode_u_64(arr[5]),
      bvCid: dco_decode_i_64(arr[6]),
      picUrl: dco_decode_String(arr[7]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<Audio> dco_decode_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_audio).toList();
  }

  @protected
  List<DescV2> dco_decode_list_desc_v_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_desc_v_2).toList();
  }

  @protected
  List<Durl> dco_decode_list_durl(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_durl).toList();
  }

  @protected
  List<Page> dco_decode_list_page(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_page).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<SearchLyricItem> dco_decode_list_search_lyric_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_search_lyric_item).toList();
  }

  @protected
  List<SupportFormat> dco_decode_list_support_format(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_support_format).toList();
  }

  @protected
  List<Video> dco_decode_list_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_video).toList();
  }

  @protected
  MsgItem dco_decode_msg_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MsgItem(
      ty: dco_decode_msg_type(arr[0]),
      data: dco_decode_String(arr[1]),
    );
  }

  @protected
  MsgType dco_decode_msg_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MsgType.values[raw as int];
  }

  @protected
  SenderProgressData?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
            raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Owner dco_decode_owner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Owner(
      mid: dco_decode_i_64(arr[0]),
      name: dco_decode_String(arr[1]),
      face: dco_decode_String(arr[2]),
    );
  }

  @protected
  Page dco_decode_page(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return Page(
      cid: dco_decode_i_64(arr[0]),
      page: dco_decode_i_64(arr[1]),
      from: dco_decode_String(arr[2]),
      part_: dco_decode_String(arr[3]),
      duration: dco_decode_i_64(arr[4]),
      vid: dco_decode_String(arr[5]),
      weblink: dco_decode_String(arr[6]),
      dimension: dco_decode_dimension(arr[7]),
      firstFrame: dco_decode_String(arr[8]),
    );
  }

  @protected
  ProgressData dco_decode_progress_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ProgressData(
      currentSize: dco_decode_u_64(arr[0]),
      totalSize: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  Rights dco_decode_rights(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16)
      throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return Rights(
      bp: dco_decode_i_64(arr[0]),
      elec: dco_decode_i_64(arr[1]),
      download: dco_decode_i_64(arr[2]),
      movie: dco_decode_i_64(arr[3]),
      pay: dco_decode_i_64(arr[4]),
      hd5: dco_decode_i_64(arr[5]),
      noReprint: dco_decode_i_64(arr[6]),
      autoplay: dco_decode_i_64(arr[7]),
      ugcPay: dco_decode_i_64(arr[8]),
      isCooperation: dco_decode_i_64(arr[9]),
      ugcPayPreview: dco_decode_i_64(arr[10]),
      noBackground: dco_decode_i_64(arr[11]),
      cleanMode: dco_decode_i_64(arr[12]),
      isSteinGate: dco_decode_i_64(arr[13]),
      is360: dco_decode_i_64(arr[14]),
      noShare: dco_decode_i_64(arr[15]),
    );
  }

  @protected
  SearchLyricItem dco_decode_search_lyric_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SearchLyricItem(
      name: dco_decode_String(arr[0]),
      authors: dco_decode_String(arr[1]),
      token: dco_decode_String(arr[2]),
    );
  }

  @protected
  SegmentBase dco_decode_segment_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SegmentBase(
      initialization: dco_decode_String(arr[0]),
      indexRange: dco_decode_String(arr[1]),
    );
  }

  @protected
  Stat dco_decode_stat(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return Stat(
      aid: dco_decode_i_64(arr[0]),
      view: dco_decode_i_64(arr[1]),
      danmaku: dco_decode_i_64(arr[2]),
      reply: dco_decode_i_64(arr[3]),
      favorite: dco_decode_i_64(arr[4]),
      coin: dco_decode_i_64(arr[5]),
      share: dco_decode_i_64(arr[6]),
      nowRank: dco_decode_i_64(arr[7]),
      hisRank: dco_decode_i_64(arr[8]),
      like: dco_decode_i_64(arr[9]),
      dislike: dco_decode_i_64(arr[10]),
      evaluation: dco_decode_String(arr[11]),
      argueMsg: dco_decode_String(arr[12]),
    );
  }

  @protected
  SupportFormat dco_decode_support_format(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return SupportFormat(
      quality: dco_decode_i_64(arr[0]),
      format: dco_decode_String(arr[1]),
      newDescription: dco_decode_String(arr[2]),
      displayDesc: dco_decode_String(arr[3]),
      superscript: dco_decode_String(arr[4]),
    );
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  Video dco_decode_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 17)
      throw Exception('unexpected arr length: expect 17 but see ${arr.length}');
    return Video(
      id: dco_decode_i_64(arr[0]),
      baseUrl: dco_decode_String(arr[1]),
      backupUrl: dco_decode_list_String(arr[2]),
      backupUrl2: dco_decode_list_String(arr[3]),
      bandwidth: dco_decode_i_64(arr[4]),
      mimeType: dco_decode_String(arr[5]),
      mimeType2: dco_decode_String(arr[6]),
      codecs: dco_decode_String(arr[7]),
      width: dco_decode_i_64(arr[8]),
      height: dco_decode_i_64(arr[9]),
      frameRate: dco_decode_String(arr[10]),
      frameRate2: dco_decode_String(arr[11]),
      sar: dco_decode_String(arr[12]),
      startWithSap: dco_decode_i_64(arr[13]),
      startWithSap2: dco_decode_i_64(arr[14]),
      segmentBase: dco_decode_segment_base(arr[15]),
      codecid: dco_decode_i_64(arr[16]),
    );
  }

  @protected
  VideoQuality dco_decode_video_quality(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return VideoQuality(
      code: dco_decode_i_64(arr[0]),
    );
  }

  @protected
  VideoUrl dco_decode_video_url(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return VideoUrl(
      from: dco_decode_String(arr[0]),
      result: dco_decode_String(arr[1]),
      message: dco_decode_String(arr[2]),
      quality: dco_decode_i_64(arr[3]),
      format: dco_decode_String(arr[4]),
      timelength: dco_decode_i_64(arr[5]),
      acceptFormat: dco_decode_String(arr[6]),
      acceptDescription: dco_decode_list_String(arr[7]),
      acceptQuality: dco_decode_list_prim_i_64_strict(arr[8]),
      videoCodecid: dco_decode_i_64(arr[9]),
      seekParam: dco_decode_String(arr[10]),
      seekType: dco_decode_String(arr[11]),
      durl: dco_decode_list_durl(arr[12]),
      supportFormats: dco_decode_list_support_format(arr[13]),
      dash: dco_decode_dash(arr[14]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Client
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SenderProgressData
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SenderProgressDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SenderProgressData
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SenderProgressDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RustStreamSink<MsgItem> sse_decode_StreamSink_msg_item_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  RustStreamSink<ProgressData> sse_decode_StreamSink_progress_data_Sse(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    throw UnimplementedError('Unreachable ()');
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Audio sse_decode_audio(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_baseUrl = sse_decode_String(deserializer);
    var var_backupUrl = sse_decode_list_String(deserializer);
    var var_backupUrl2 = sse_decode_list_String(deserializer);
    var var_bandwidth = sse_decode_i_64(deserializer);
    var var_mimeType = sse_decode_String(deserializer);
    var var_mimeType2 = sse_decode_String(deserializer);
    var var_codecs = sse_decode_String(deserializer);
    var var_width = sse_decode_i_64(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    var var_frameRate = sse_decode_String(deserializer);
    var var_frameRate2 = sse_decode_String(deserializer);
    var var_sar = sse_decode_String(deserializer);
    var var_startWithSap = sse_decode_i_64(deserializer);
    var var_startWithSap2 = sse_decode_i_64(deserializer);
    var var_segmentBase = sse_decode_segment_base(deserializer);
    var var_codecid = sse_decode_i_64(deserializer);
    return Audio(
        id: var_id,
        baseUrl: var_baseUrl,
        backupUrl: var_backupUrl,
        backupUrl2: var_backupUrl2,
        bandwidth: var_bandwidth,
        mimeType: var_mimeType,
        mimeType2: var_mimeType2,
        codecs: var_codecs,
        width: var_width,
        height: var_height,
        frameRate: var_frameRate,
        frameRate2: var_frameRate2,
        sar: var_sar,
        startWithSap: var_startWithSap,
        startWithSap2: var_startWithSap2,
        segmentBase: var_segmentBase,
        codecid: var_codecid);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  SenderProgressData
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
        deserializer));
  }

  @protected
  MsgItem sse_decode_box_autoadd_msg_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_msg_item(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  VideoQuality sse_decode_box_autoadd_video_quality(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_video_quality(deserializer));
  }

  @protected
  BvInfo sse_decode_bv_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bvid = sse_decode_String(deserializer);
    var var_aid = sse_decode_i_64(deserializer);
    var var_videos = sse_decode_i_64(deserializer);
    var var_tid = sse_decode_i_64(deserializer);
    var var_copyright = sse_decode_i_64(deserializer);
    var var_pic = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_ctime = sse_decode_i_64(deserializer);
    var var_desc = sse_decode_String(deserializer);
    var var_descV2 = sse_decode_list_desc_v_2(deserializer);
    var var_rights = sse_decode_rights(deserializer);
    var var_owner = sse_decode_owner(deserializer);
    var var_stat = sse_decode_stat(deserializer);
    var var_state = sse_decode_i_64(deserializer);
    var var_duration = sse_decode_i_64(deserializer);
    var var_dynamic_ = sse_decode_String(deserializer);
    var var_cid = sse_decode_i_64(deserializer);
    var var_dimension = sse_decode_dimension(deserializer);
    var var_noCache = sse_decode_bool(deserializer);
    var var_pages = sse_decode_list_page(deserializer);
    return BvInfo(
        bvid: var_bvid,
        aid: var_aid,
        videos: var_videos,
        tid: var_tid,
        copyright: var_copyright,
        pic: var_pic,
        title: var_title,
        ctime: var_ctime,
        desc: var_desc,
        descV2: var_descV2,
        rights: var_rights,
        owner: var_owner,
        stat: var_stat,
        state: var_state,
        duration: var_duration,
        dynamic_: var_dynamic_,
        cid: var_cid,
        dimension: var_dimension,
        noCache: var_noCache,
        pages: var_pages);
  }

  @protected
  Dash sse_decode_dash(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_duration = sse_decode_i_64(deserializer);
    var var_minBufferTime = sse_decode_f_64(deserializer);
    var var_minBufferTime2 = sse_decode_f_64(deserializer);
    var var_video = sse_decode_list_video(deserializer);
    var var_audio = sse_decode_list_audio(deserializer);
    return Dash(
        duration: var_duration,
        minBufferTime: var_minBufferTime,
        minBufferTime2: var_minBufferTime2,
        video: var_video,
        audio: var_audio);
  }

  @protected
  DescV2 sse_decode_desc_v_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_rawText = sse_decode_String(deserializer);
    var var_descType = sse_decode_i_64(deserializer);
    var var_bizId = sse_decode_i_64(deserializer);
    var var_rights = sse_decode_rights(deserializer);
    var var_owner = sse_decode_owner(deserializer);
    var var_stat = sse_decode_stat(deserializer);
    return DescV2(
        rawText: var_rawText,
        descType: var_descType,
        bizId: var_bizId,
        rights: var_rights,
        owner: var_owner,
        stat: var_stat);
  }

  @protected
  Dimension sse_decode_dimension(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_64(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    var var_rotate = sse_decode_i_64(deserializer);
    return Dimension(width: var_width, height: var_height, rotate: var_rotate);
  }

  @protected
  Durl sse_decode_durl(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_order = sse_decode_i_64(deserializer);
    var var_length = sse_decode_i_64(deserializer);
    var var_size = sse_decode_i_64(deserializer);
    var var_ahead = sse_decode_String(deserializer);
    var var_vhead = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_backupUrl = sse_decode_list_String(deserializer);
    return Durl(
        order: var_order,
        length: var_length,
        size: var_size,
        ahead: var_ahead,
        vhead: var_vhead,
        url: var_url,
        backupUrl: var_backupUrl);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  InfoData sse_decode_info_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_author = sse_decode_String(deserializer);
    var var_videoId = sse_decode_String(deserializer);
    var var_shortDescription = sse_decode_String(deserializer);
    var var_viewCount = sse_decode_u_64(deserializer);
    var var_lengthSeconds = sse_decode_u_64(deserializer);
    var var_bvCid = sse_decode_i_64(deserializer);
    var var_picUrl = sse_decode_String(deserializer);
    return InfoData(
        title: var_title,
        author: var_author,
        videoId: var_videoId,
        shortDescription: var_shortDescription,
        viewCount: var_viewCount,
        lengthSeconds: var_lengthSeconds,
        bvCid: var_bvCid,
        picUrl: var_picUrl);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<Audio> sse_decode_list_audio(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Audio>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_audio(deserializer));
    }
    return ans_;
  }

  @protected
  List<DescV2> sse_decode_list_desc_v_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DescV2>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_desc_v_2(deserializer));
    }
    return ans_;
  }

  @protected
  List<Durl> sse_decode_list_durl(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Durl>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_durl(deserializer));
    }
    return ans_;
  }

  @protected
  List<Page> sse_decode_list_page(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Page>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_page(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<SearchLyricItem> sse_decode_list_search_lyric_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SearchLyricItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_search_lyric_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<SupportFormat> sse_decode_list_support_format(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SupportFormat>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_support_format(deserializer));
    }
    return ans_;
  }

  @protected
  List<Video> sse_decode_list_video(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Video>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_video(deserializer));
    }
    return ans_;
  }

  @protected
  MsgItem sse_decode_msg_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ty = sse_decode_msg_type(deserializer);
    var var_data = sse_decode_String(deserializer);
    return MsgItem(ty: var_ty, data: var_data);
  }

  @protected
  MsgType sse_decode_msg_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MsgType.values[inner];
  }

  @protected
  SenderProgressData?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Owner sse_decode_owner(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_mid = sse_decode_i_64(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_face = sse_decode_String(deserializer);
    return Owner(mid: var_mid, name: var_name, face: var_face);
  }

  @protected
  Page sse_decode_page(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cid = sse_decode_i_64(deserializer);
    var var_page = sse_decode_i_64(deserializer);
    var var_from = sse_decode_String(deserializer);
    var var_part_ = sse_decode_String(deserializer);
    var var_duration = sse_decode_i_64(deserializer);
    var var_vid = sse_decode_String(deserializer);
    var var_weblink = sse_decode_String(deserializer);
    var var_dimension = sse_decode_dimension(deserializer);
    var var_firstFrame = sse_decode_String(deserializer);
    return Page(
        cid: var_cid,
        page: var_page,
        from: var_from,
        part_: var_part_,
        duration: var_duration,
        vid: var_vid,
        weblink: var_weblink,
        dimension: var_dimension,
        firstFrame: var_firstFrame);
  }

  @protected
  ProgressData sse_decode_progress_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_currentSize = sse_decode_u_64(deserializer);
    var var_totalSize = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ProgressData(currentSize: var_currentSize, totalSize: var_totalSize);
  }

  @protected
  Rights sse_decode_rights(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bp = sse_decode_i_64(deserializer);
    var var_elec = sse_decode_i_64(deserializer);
    var var_download = sse_decode_i_64(deserializer);
    var var_movie = sse_decode_i_64(deserializer);
    var var_pay = sse_decode_i_64(deserializer);
    var var_hd5 = sse_decode_i_64(deserializer);
    var var_noReprint = sse_decode_i_64(deserializer);
    var var_autoplay = sse_decode_i_64(deserializer);
    var var_ugcPay = sse_decode_i_64(deserializer);
    var var_isCooperation = sse_decode_i_64(deserializer);
    var var_ugcPayPreview = sse_decode_i_64(deserializer);
    var var_noBackground = sse_decode_i_64(deserializer);
    var var_cleanMode = sse_decode_i_64(deserializer);
    var var_isSteinGate = sse_decode_i_64(deserializer);
    var var_is360 = sse_decode_i_64(deserializer);
    var var_noShare = sse_decode_i_64(deserializer);
    return Rights(
        bp: var_bp,
        elec: var_elec,
        download: var_download,
        movie: var_movie,
        pay: var_pay,
        hd5: var_hd5,
        noReprint: var_noReprint,
        autoplay: var_autoplay,
        ugcPay: var_ugcPay,
        isCooperation: var_isCooperation,
        ugcPayPreview: var_ugcPayPreview,
        noBackground: var_noBackground,
        cleanMode: var_cleanMode,
        isSteinGate: var_isSteinGate,
        is360: var_is360,
        noShare: var_noShare);
  }

  @protected
  SearchLyricItem sse_decode_search_lyric_item(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_authors = sse_decode_String(deserializer);
    var var_token = sse_decode_String(deserializer);
    return SearchLyricItem(
        name: var_name, authors: var_authors, token: var_token);
  }

  @protected
  SegmentBase sse_decode_segment_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_initialization = sse_decode_String(deserializer);
    var var_indexRange = sse_decode_String(deserializer);
    return SegmentBase(
        initialization: var_initialization, indexRange: var_indexRange);
  }

  @protected
  Stat sse_decode_stat(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_aid = sse_decode_i_64(deserializer);
    var var_view = sse_decode_i_64(deserializer);
    var var_danmaku = sse_decode_i_64(deserializer);
    var var_reply = sse_decode_i_64(deserializer);
    var var_favorite = sse_decode_i_64(deserializer);
    var var_coin = sse_decode_i_64(deserializer);
    var var_share = sse_decode_i_64(deserializer);
    var var_nowRank = sse_decode_i_64(deserializer);
    var var_hisRank = sse_decode_i_64(deserializer);
    var var_like = sse_decode_i_64(deserializer);
    var var_dislike = sse_decode_i_64(deserializer);
    var var_evaluation = sse_decode_String(deserializer);
    var var_argueMsg = sse_decode_String(deserializer);
    return Stat(
        aid: var_aid,
        view: var_view,
        danmaku: var_danmaku,
        reply: var_reply,
        favorite: var_favorite,
        coin: var_coin,
        share: var_share,
        nowRank: var_nowRank,
        hisRank: var_hisRank,
        like: var_like,
        dislike: var_dislike,
        evaluation: var_evaluation,
        argueMsg: var_argueMsg);
  }

  @protected
  SupportFormat sse_decode_support_format(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_quality = sse_decode_i_64(deserializer);
    var var_format = sse_decode_String(deserializer);
    var var_newDescription = sse_decode_String(deserializer);
    var var_displayDesc = sse_decode_String(deserializer);
    var var_superscript = sse_decode_String(deserializer);
    return SupportFormat(
        quality: var_quality,
        format: var_format,
        newDescription: var_newDescription,
        displayDesc: var_displayDesc,
        superscript: var_superscript);
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  Video sse_decode_video(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_i_64(deserializer);
    var var_baseUrl = sse_decode_String(deserializer);
    var var_backupUrl = sse_decode_list_String(deserializer);
    var var_backupUrl2 = sse_decode_list_String(deserializer);
    var var_bandwidth = sse_decode_i_64(deserializer);
    var var_mimeType = sse_decode_String(deserializer);
    var var_mimeType2 = sse_decode_String(deserializer);
    var var_codecs = sse_decode_String(deserializer);
    var var_width = sse_decode_i_64(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    var var_frameRate = sse_decode_String(deserializer);
    var var_frameRate2 = sse_decode_String(deserializer);
    var var_sar = sse_decode_String(deserializer);
    var var_startWithSap = sse_decode_i_64(deserializer);
    var var_startWithSap2 = sse_decode_i_64(deserializer);
    var var_segmentBase = sse_decode_segment_base(deserializer);
    var var_codecid = sse_decode_i_64(deserializer);
    return Video(
        id: var_id,
        baseUrl: var_baseUrl,
        backupUrl: var_backupUrl,
        backupUrl2: var_backupUrl2,
        bandwidth: var_bandwidth,
        mimeType: var_mimeType,
        mimeType2: var_mimeType2,
        codecs: var_codecs,
        width: var_width,
        height: var_height,
        frameRate: var_frameRate,
        frameRate2: var_frameRate2,
        sar: var_sar,
        startWithSap: var_startWithSap,
        startWithSap2: var_startWithSap2,
        segmentBase: var_segmentBase,
        codecid: var_codecid);
  }

  @protected
  VideoQuality sse_decode_video_quality(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_code = sse_decode_i_64(deserializer);
    return VideoQuality(code: var_code);
  }

  @protected
  VideoUrl sse_decode_video_url(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_from = sse_decode_String(deserializer);
    var var_result = sse_decode_String(deserializer);
    var var_message = sse_decode_String(deserializer);
    var var_quality = sse_decode_i_64(deserializer);
    var var_format = sse_decode_String(deserializer);
    var var_timelength = sse_decode_i_64(deserializer);
    var var_acceptFormat = sse_decode_String(deserializer);
    var var_acceptDescription = sse_decode_list_String(deserializer);
    var var_acceptQuality = sse_decode_list_prim_i_64_strict(deserializer);
    var var_videoCodecid = sse_decode_i_64(deserializer);
    var var_seekParam = sse_decode_String(deserializer);
    var var_seekType = sse_decode_String(deserializer);
    var var_durl = sse_decode_list_durl(deserializer);
    var var_supportFormats = sse_decode_list_support_format(deserializer);
    var var_dash = sse_decode_dash(deserializer);
    return VideoUrl(
        from: var_from,
        result: var_result,
        message: var_message,
        quality: var_quality,
        format: var_format,
        timelength: var_timelength,
        acceptFormat: var_acceptFormat,
        acceptDescription: var_acceptDescription,
        acceptQuality: var_acceptQuality,
        videoCodecid: var_videoCodecid,
        seekParam: var_seekParam,
        seekType: var_seekType,
        durl: var_durl,
        supportFormats: var_supportFormats,
        dash: var_dash);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SenderProgressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SenderProgressDataImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SenderProgressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SenderProgressDataImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_msg_item_Sse(
      RustStreamSink<MsgItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_msg_item,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_StreamSink_progress_data_Sse(
      RustStreamSink<ProgressData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(
        self.setupAndSerialize(
            codec: SseCodec(
          decodeSuccessData: sse_decode_progress_data,
          decodeErrorData: sse_decode_AnyhowException,
        )),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_audio(Audio self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_list_String(self.backupUrl, serializer);
    sse_encode_list_String(self.backupUrl2, serializer);
    sse_encode_i_64(self.bandwidth, serializer);
    sse_encode_String(self.mimeType, serializer);
    sse_encode_String(self.mimeType2, serializer);
    sse_encode_String(self.codecs, serializer);
    sse_encode_i_64(self.width, serializer);
    sse_encode_i_64(self.height, serializer);
    sse_encode_String(self.frameRate, serializer);
    sse_encode_String(self.frameRate2, serializer);
    sse_encode_String(self.sar, serializer);
    sse_encode_i_64(self.startWithSap, serializer);
    sse_encode_i_64(self.startWithSap2, serializer);
    sse_encode_segment_base(self.segmentBase, serializer);
    sse_encode_i_64(self.codecid, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SenderProgressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_msg_item(MsgItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_msg_item(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_video_quality(
      VideoQuality self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_video_quality(self, serializer);
  }

  @protected
  void sse_encode_bv_info(BvInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.bvid, serializer);
    sse_encode_i_64(self.aid, serializer);
    sse_encode_i_64(self.videos, serializer);
    sse_encode_i_64(self.tid, serializer);
    sse_encode_i_64(self.copyright, serializer);
    sse_encode_String(self.pic, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_64(self.ctime, serializer);
    sse_encode_String(self.desc, serializer);
    sse_encode_list_desc_v_2(self.descV2, serializer);
    sse_encode_rights(self.rights, serializer);
    sse_encode_owner(self.owner, serializer);
    sse_encode_stat(self.stat, serializer);
    sse_encode_i_64(self.state, serializer);
    sse_encode_i_64(self.duration, serializer);
    sse_encode_String(self.dynamic_, serializer);
    sse_encode_i_64(self.cid, serializer);
    sse_encode_dimension(self.dimension, serializer);
    sse_encode_bool(self.noCache, serializer);
    sse_encode_list_page(self.pages, serializer);
  }

  @protected
  void sse_encode_dash(Dash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.duration, serializer);
    sse_encode_f_64(self.minBufferTime, serializer);
    sse_encode_f_64(self.minBufferTime2, serializer);
    sse_encode_list_video(self.video, serializer);
    sse_encode_list_audio(self.audio, serializer);
  }

  @protected
  void sse_encode_desc_v_2(DescV2 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.rawText, serializer);
    sse_encode_i_64(self.descType, serializer);
    sse_encode_i_64(self.bizId, serializer);
    sse_encode_rights(self.rights, serializer);
    sse_encode_owner(self.owner, serializer);
    sse_encode_stat(self.stat, serializer);
  }

  @protected
  void sse_encode_dimension(Dimension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.width, serializer);
    sse_encode_i_64(self.height, serializer);
    sse_encode_i_64(self.rotate, serializer);
  }

  @protected
  void sse_encode_durl(Durl self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.order, serializer);
    sse_encode_i_64(self.length, serializer);
    sse_encode_i_64(self.size, serializer);
    sse_encode_String(self.ahead, serializer);
    sse_encode_String(self.vhead, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_list_String(self.backupUrl, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_info_data(InfoData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.author, serializer);
    sse_encode_String(self.videoId, serializer);
    sse_encode_String(self.shortDescription, serializer);
    sse_encode_u_64(self.viewCount, serializer);
    sse_encode_u_64(self.lengthSeconds, serializer);
    sse_encode_i_64(self.bvCid, serializer);
    sse_encode_String(self.picUrl, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_audio(List<Audio> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_audio(item, serializer);
    }
  }

  @protected
  void sse_encode_list_desc_v_2(List<DescV2> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_desc_v_2(item, serializer);
    }
  }

  @protected
  void sse_encode_list_durl(List<Durl> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_durl(item, serializer);
    }
  }

  @protected
  void sse_encode_list_page(List<Page> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_page(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
      Int64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_search_lyric_item(
      List<SearchLyricItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_search_lyric_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_support_format(
      List<SupportFormat> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_support_format(item, serializer);
    }
  }

  @protected
  void sse_encode_list_video(List<Video> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_video(item, serializer);
    }
  }

  @protected
  void sse_encode_msg_item(MsgItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_msg_type(self.ty, serializer);
    sse_encode_String(self.data, serializer);
  }

  @protected
  void sse_encode_msg_type(MsgType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          SenderProgressData? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSenderProgressData(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_owner(Owner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.mid, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.face, serializer);
  }

  @protected
  void sse_encode_page(Page self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.cid, serializer);
    sse_encode_i_64(self.page, serializer);
    sse_encode_String(self.from, serializer);
    sse_encode_String(self.part_, serializer);
    sse_encode_i_64(self.duration, serializer);
    sse_encode_String(self.vid, serializer);
    sse_encode_String(self.weblink, serializer);
    sse_encode_dimension(self.dimension, serializer);
    sse_encode_String(self.firstFrame, serializer);
  }

  @protected
  void sse_encode_progress_data(ProgressData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.currentSize, serializer);
    sse_encode_opt_box_autoadd_u_64(self.totalSize, serializer);
  }

  @protected
  void sse_encode_rights(Rights self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.bp, serializer);
    sse_encode_i_64(self.elec, serializer);
    sse_encode_i_64(self.download, serializer);
    sse_encode_i_64(self.movie, serializer);
    sse_encode_i_64(self.pay, serializer);
    sse_encode_i_64(self.hd5, serializer);
    sse_encode_i_64(self.noReprint, serializer);
    sse_encode_i_64(self.autoplay, serializer);
    sse_encode_i_64(self.ugcPay, serializer);
    sse_encode_i_64(self.isCooperation, serializer);
    sse_encode_i_64(self.ugcPayPreview, serializer);
    sse_encode_i_64(self.noBackground, serializer);
    sse_encode_i_64(self.cleanMode, serializer);
    sse_encode_i_64(self.isSteinGate, serializer);
    sse_encode_i_64(self.is360, serializer);
    sse_encode_i_64(self.noShare, serializer);
  }

  @protected
  void sse_encode_search_lyric_item(
      SearchLyricItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.authors, serializer);
    sse_encode_String(self.token, serializer);
  }

  @protected
  void sse_encode_segment_base(SegmentBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.initialization, serializer);
    sse_encode_String(self.indexRange, serializer);
  }

  @protected
  void sse_encode_stat(Stat self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.aid, serializer);
    sse_encode_i_64(self.view, serializer);
    sse_encode_i_64(self.danmaku, serializer);
    sse_encode_i_64(self.reply, serializer);
    sse_encode_i_64(self.favorite, serializer);
    sse_encode_i_64(self.coin, serializer);
    sse_encode_i_64(self.share, serializer);
    sse_encode_i_64(self.nowRank, serializer);
    sse_encode_i_64(self.hisRank, serializer);
    sse_encode_i_64(self.like, serializer);
    sse_encode_i_64(self.dislike, serializer);
    sse_encode_String(self.evaluation, serializer);
    sse_encode_String(self.argueMsg, serializer);
  }

  @protected
  void sse_encode_support_format(SupportFormat self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.quality, serializer);
    sse_encode_String(self.format, serializer);
    sse_encode_String(self.newDescription, serializer);
    sse_encode_String(self.displayDesc, serializer);
    sse_encode_String(self.superscript, serializer);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_video(Video self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.id, serializer);
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_list_String(self.backupUrl, serializer);
    sse_encode_list_String(self.backupUrl2, serializer);
    sse_encode_i_64(self.bandwidth, serializer);
    sse_encode_String(self.mimeType, serializer);
    sse_encode_String(self.mimeType2, serializer);
    sse_encode_String(self.codecs, serializer);
    sse_encode_i_64(self.width, serializer);
    sse_encode_i_64(self.height, serializer);
    sse_encode_String(self.frameRate, serializer);
    sse_encode_String(self.frameRate2, serializer);
    sse_encode_String(self.sar, serializer);
    sse_encode_i_64(self.startWithSap, serializer);
    sse_encode_i_64(self.startWithSap2, serializer);
    sse_encode_segment_base(self.segmentBase, serializer);
    sse_encode_i_64(self.codecid, serializer);
  }

  @protected
  void sse_encode_video_quality(VideoQuality self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self.code, serializer);
  }

  @protected
  void sse_encode_video_url(VideoUrl self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.from, serializer);
    sse_encode_String(self.result, serializer);
    sse_encode_String(self.message, serializer);
    sse_encode_i_64(self.quality, serializer);
    sse_encode_String(self.format, serializer);
    sse_encode_i_64(self.timelength, serializer);
    sse_encode_String(self.acceptFormat, serializer);
    sse_encode_list_String(self.acceptDescription, serializer);
    sse_encode_list_prim_i_64_strict(self.acceptQuality, serializer);
    sse_encode_i_64(self.videoCodecid, serializer);
    sse_encode_String(self.seekParam, serializer);
    sse_encode_String(self.seekType, serializer);
    sse_encode_list_durl(self.durl, serializer);
    sse_encode_list_support_format(self.supportFormats, serializer);
    sse_encode_dash(self.dash, serializer);
  }
}

@sealed
class ClientImpl extends RustOpaque implements Client {
  // Not to be used by end users
  ClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Client,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Client,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ClientPtr,
  );

  Future<List<String>> audioUrls(
          {required String bvid, required PlatformInt64 cid}) =>
      RustLib.instance.api.crateApiBilibiliBilibiliClientAudioUrls(
          that: this, bvid: bvid, cid: cid);

  Future<void> download(
          {required String url,
          required String filePath,
          SenderProgressData? channel}) =>
      RustLib.instance.api.crateApiBilibiliBilibiliClientDownload(
          that: this, url: url, filePath: filePath, channel: channel);

  Future<List<String>> fetchIds(
          {required String keyword, required BigInt maxIdCount}) =>
      RustLib.instance.api.crateApiBilibiliBilibiliClientFetchIds(
          that: this, keyword: keyword, maxIdCount: maxIdCount);

  Future<BvInfo> info({required String bvid}) => RustLib.instance.api
      .crateApiBilibiliBilibiliClientInfo(that: this, bvid: bvid);

  Future<Uint8List> requestPic({required String url}) => RustLib.instance.api
      .crateApiBilibiliBilibiliClientRequestPic(that: this, url: url);

  Future<VideoUrl> videoUrl(
          {required String bvid,
          required PlatformInt64 cid,
          required PlatformInt64 fnval,
          required VideoQuality videoQuality}) =>
      RustLib.instance.api.crateApiBilibiliBilibiliClientVideoUrl(
          that: this,
          bvid: bvid,
          cid: cid,
          fnval: fnval,
          videoQuality: videoQuality);
}

@sealed
class SenderProgressDataImpl extends RustOpaque implements SenderProgressData {
  // Not to be used by end users
  SenderProgressDataImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SenderProgressDataImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SenderProgressData,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SenderProgressData,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_SenderProgressDataPtr,
  );
}
