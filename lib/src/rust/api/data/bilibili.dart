// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `default_bool`, `default_dash`, `default_dimension`, `default_i64`, `default_option`, `default_owner`, `default_rights`, `default_stat`, `default_string`, `default_vec`, `null_vec`
// These types are ignored because they are not used by any `pub` functions: `Response`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deserialize`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `serialize`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`

class Audio {
  final PlatformInt64 id;
  final String baseUrl;
  final List<String> backupUrl;
  final List<String> backupUrl2;
  final PlatformInt64 bandwidth;
  final String mimeType;
  final String mimeType2;
  final String codecs;
  final PlatformInt64 width;
  final PlatformInt64 height;
  final String frameRate;
  final String frameRate2;
  final String sar;
  final PlatformInt64 startWithSap;
  final PlatformInt64 startWithSap2;
  final SegmentBase segmentBase;
  final PlatformInt64 codecid;

  const Audio({
    required this.id,
    required this.baseUrl,
    required this.backupUrl,
    required this.backupUrl2,
    required this.bandwidth,
    required this.mimeType,
    required this.mimeType2,
    required this.codecs,
    required this.width,
    required this.height,
    required this.frameRate,
    required this.frameRate2,
    required this.sar,
    required this.startWithSap,
    required this.startWithSap2,
    required this.segmentBase,
    required this.codecid,
  });

  static Future<Audio> default_() =>
      RustLib.instance.api.crateApiDataBilibiliAudioDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      baseUrl.hashCode ^
      backupUrl.hashCode ^
      backupUrl2.hashCode ^
      bandwidth.hashCode ^
      mimeType.hashCode ^
      mimeType2.hashCode ^
      codecs.hashCode ^
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      frameRate2.hashCode ^
      sar.hashCode ^
      startWithSap.hashCode ^
      startWithSap2.hashCode ^
      segmentBase.hashCode ^
      codecid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Audio &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          baseUrl == other.baseUrl &&
          backupUrl == other.backupUrl &&
          backupUrl2 == other.backupUrl2 &&
          bandwidth == other.bandwidth &&
          mimeType == other.mimeType &&
          mimeType2 == other.mimeType2 &&
          codecs == other.codecs &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          frameRate2 == other.frameRate2 &&
          sar == other.sar &&
          startWithSap == other.startWithSap &&
          startWithSap2 == other.startWithSap2 &&
          segmentBase == other.segmentBase &&
          codecid == other.codecid;
}

class BvInfo {
  final String bvid;
  final PlatformInt64 aid;
  final PlatformInt64 videos;
  final PlatformInt64 tid;
  final PlatformInt64 copyright;
  final String pic;
  final String title;
  final PlatformInt64 ctime;
  final String desc;
  final List<DescV2> descV2;
  final Rights rights;
  final Owner owner;
  final Stat stat;
  final PlatformInt64 state;
  final PlatformInt64 duration;
  final String dynamic_;
  final PlatformInt64 cid;
  final Dimension dimension;
  final bool noCache;
  final List<Page> pages;

  const BvInfo({
    required this.bvid,
    required this.aid,
    required this.videos,
    required this.tid,
    required this.copyright,
    required this.pic,
    required this.title,
    required this.ctime,
    required this.desc,
    required this.descV2,
    required this.rights,
    required this.owner,
    required this.stat,
    required this.state,
    required this.duration,
    required this.dynamic_,
    required this.cid,
    required this.dimension,
    required this.noCache,
    required this.pages,
  });

  static Future<BvInfo> default_() =>
      RustLib.instance.api.crateApiDataBilibiliBvInfoDefault();

  @override
  int get hashCode =>
      bvid.hashCode ^
      aid.hashCode ^
      videos.hashCode ^
      tid.hashCode ^
      copyright.hashCode ^
      pic.hashCode ^
      title.hashCode ^
      ctime.hashCode ^
      desc.hashCode ^
      descV2.hashCode ^
      rights.hashCode ^
      owner.hashCode ^
      stat.hashCode ^
      state.hashCode ^
      duration.hashCode ^
      dynamic_.hashCode ^
      cid.hashCode ^
      dimension.hashCode ^
      noCache.hashCode ^
      pages.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BvInfo &&
          runtimeType == other.runtimeType &&
          bvid == other.bvid &&
          aid == other.aid &&
          videos == other.videos &&
          tid == other.tid &&
          copyright == other.copyright &&
          pic == other.pic &&
          title == other.title &&
          ctime == other.ctime &&
          desc == other.desc &&
          descV2 == other.descV2 &&
          rights == other.rights &&
          owner == other.owner &&
          stat == other.stat &&
          state == other.state &&
          duration == other.duration &&
          dynamic_ == other.dynamic_ &&
          cid == other.cid &&
          dimension == other.dimension &&
          noCache == other.noCache &&
          pages == other.pages;
}

class Dash {
  final PlatformInt64 duration;
  final double minBufferTime;
  final double minBufferTime2;
  final List<Video> video;
  final List<Audio> audio;

  const Dash({
    required this.duration,
    required this.minBufferTime,
    required this.minBufferTime2,
    required this.video,
    required this.audio,
  });

  static Future<Dash> default_() =>
      RustLib.instance.api.crateApiDataBilibiliDashDefault();

  @override
  int get hashCode =>
      duration.hashCode ^
      minBufferTime.hashCode ^
      minBufferTime2.hashCode ^
      video.hashCode ^
      audio.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Dash &&
          runtimeType == other.runtimeType &&
          duration == other.duration &&
          minBufferTime == other.minBufferTime &&
          minBufferTime2 == other.minBufferTime2 &&
          video == other.video &&
          audio == other.audio;
}

class DescV2 {
  final String rawText;
  final PlatformInt64 descType;
  final PlatformInt64 bizId;
  final Rights rights;
  final Owner owner;
  final Stat stat;

  const DescV2({
    required this.rawText,
    required this.descType,
    required this.bizId,
    required this.rights,
    required this.owner,
    required this.stat,
  });

  static Future<DescV2> default_() =>
      RustLib.instance.api.crateApiDataBilibiliDescV2Default();

  @override
  int get hashCode =>
      rawText.hashCode ^
      descType.hashCode ^
      bizId.hashCode ^
      rights.hashCode ^
      owner.hashCode ^
      stat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DescV2 &&
          runtimeType == other.runtimeType &&
          rawText == other.rawText &&
          descType == other.descType &&
          bizId == other.bizId &&
          rights == other.rights &&
          owner == other.owner &&
          stat == other.stat;
}

class Dimension {
  final PlatformInt64 width;
  final PlatformInt64 height;
  final PlatformInt64 rotate;

  const Dimension({
    required this.width,
    required this.height,
    required this.rotate,
  });

  static Future<Dimension> default_() =>
      RustLib.instance.api.crateApiDataBilibiliDimensionDefault();

  @override
  int get hashCode => width.hashCode ^ height.hashCode ^ rotate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Dimension &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          rotate == other.rotate;
}

class Durl {
  final PlatformInt64 order;
  final PlatformInt64 length;
  final PlatformInt64 size;
  final String ahead;
  final String vhead;
  final String url;
  final List<String> backupUrl;

  const Durl({
    required this.order,
    required this.length,
    required this.size,
    required this.ahead,
    required this.vhead,
    required this.url,
    required this.backupUrl,
  });

  static Future<Durl> default_() =>
      RustLib.instance.api.crateApiDataBilibiliDurlDefault();

  @override
  int get hashCode =>
      order.hashCode ^
      length.hashCode ^
      size.hashCode ^
      ahead.hashCode ^
      vhead.hashCode ^
      url.hashCode ^
      backupUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Durl &&
          runtimeType == other.runtimeType &&
          order == other.order &&
          length == other.length &&
          size == other.size &&
          ahead == other.ahead &&
          vhead == other.vhead &&
          url == other.url &&
          backupUrl == other.backupUrl;
}

class Owner {
  final PlatformInt64 mid;
  final String name;
  final String face;

  const Owner({
    required this.mid,
    required this.name,
    required this.face,
  });

  static Future<Owner> default_() =>
      RustLib.instance.api.crateApiDataBilibiliOwnerDefault();

  @override
  int get hashCode => mid.hashCode ^ name.hashCode ^ face.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Owner &&
          runtimeType == other.runtimeType &&
          mid == other.mid &&
          name == other.name &&
          face == other.face;
}

class Page {
  final PlatformInt64 cid;
  final PlatformInt64 page;
  final String from;
  final String part_;
  final PlatformInt64 duration;
  final String vid;
  final String weblink;
  final Dimension dimension;
  final String firstFrame;

  const Page({
    required this.cid,
    required this.page,
    required this.from,
    required this.part_,
    required this.duration,
    required this.vid,
    required this.weblink,
    required this.dimension,
    required this.firstFrame,
  });

  static Future<Page> default_() =>
      RustLib.instance.api.crateApiDataBilibiliPageDefault();

  @override
  int get hashCode =>
      cid.hashCode ^
      page.hashCode ^
      from.hashCode ^
      part_.hashCode ^
      duration.hashCode ^
      vid.hashCode ^
      weblink.hashCode ^
      dimension.hashCode ^
      firstFrame.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Page &&
          runtimeType == other.runtimeType &&
          cid == other.cid &&
          page == other.page &&
          from == other.from &&
          part_ == other.part_ &&
          duration == other.duration &&
          vid == other.vid &&
          weblink == other.weblink &&
          dimension == other.dimension &&
          firstFrame == other.firstFrame;
}

class Rights {
  final PlatformInt64 bp;
  final PlatformInt64 elec;
  final PlatformInt64 download;
  final PlatformInt64 movie;
  final PlatformInt64 pay;
  final PlatformInt64 hd5;
  final PlatformInt64 noReprint;
  final PlatformInt64 autoplay;
  final PlatformInt64 ugcPay;
  final PlatformInt64 isCooperation;
  final PlatformInt64 ugcPayPreview;
  final PlatformInt64 noBackground;
  final PlatformInt64 cleanMode;
  final PlatformInt64 isSteinGate;
  final PlatformInt64 is360;
  final PlatformInt64 noShare;

  const Rights({
    required this.bp,
    required this.elec,
    required this.download,
    required this.movie,
    required this.pay,
    required this.hd5,
    required this.noReprint,
    required this.autoplay,
    required this.ugcPay,
    required this.isCooperation,
    required this.ugcPayPreview,
    required this.noBackground,
    required this.cleanMode,
    required this.isSteinGate,
    required this.is360,
    required this.noShare,
  });

  static Future<Rights> default_() =>
      RustLib.instance.api.crateApiDataBilibiliRightsDefault();

  @override
  int get hashCode =>
      bp.hashCode ^
      elec.hashCode ^
      download.hashCode ^
      movie.hashCode ^
      pay.hashCode ^
      hd5.hashCode ^
      noReprint.hashCode ^
      autoplay.hashCode ^
      ugcPay.hashCode ^
      isCooperation.hashCode ^
      ugcPayPreview.hashCode ^
      noBackground.hashCode ^
      cleanMode.hashCode ^
      isSteinGate.hashCode ^
      is360.hashCode ^
      noShare.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Rights &&
          runtimeType == other.runtimeType &&
          bp == other.bp &&
          elec == other.elec &&
          download == other.download &&
          movie == other.movie &&
          pay == other.pay &&
          hd5 == other.hd5 &&
          noReprint == other.noReprint &&
          autoplay == other.autoplay &&
          ugcPay == other.ugcPay &&
          isCooperation == other.isCooperation &&
          ugcPayPreview == other.ugcPayPreview &&
          noBackground == other.noBackground &&
          cleanMode == other.cleanMode &&
          isSteinGate == other.isSteinGate &&
          is360 == other.is360 &&
          noShare == other.noShare;
}

class SegmentBase {
  final String initialization;
  final String indexRange;

  const SegmentBase({
    required this.initialization,
    required this.indexRange,
  });

  static Future<SegmentBase> default_() =>
      RustLib.instance.api.crateApiDataBilibiliSegmentBaseDefault();

  @override
  int get hashCode => initialization.hashCode ^ indexRange.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SegmentBase &&
          runtimeType == other.runtimeType &&
          initialization == other.initialization &&
          indexRange == other.indexRange;
}

class Stat {
  final PlatformInt64 aid;
  final PlatformInt64 view;
  final PlatformInt64 danmaku;
  final PlatformInt64 reply;
  final PlatformInt64 favorite;
  final PlatformInt64 coin;
  final PlatformInt64 share;
  final PlatformInt64 nowRank;
  final PlatformInt64 hisRank;
  final PlatformInt64 like;
  final PlatformInt64 dislike;
  final String evaluation;
  final String argueMsg;

  const Stat({
    required this.aid,
    required this.view,
    required this.danmaku,
    required this.reply,
    required this.favorite,
    required this.coin,
    required this.share,
    required this.nowRank,
    required this.hisRank,
    required this.like,
    required this.dislike,
    required this.evaluation,
    required this.argueMsg,
  });

  static Future<Stat> default_() =>
      RustLib.instance.api.crateApiDataBilibiliStatDefault();

  @override
  int get hashCode =>
      aid.hashCode ^
      view.hashCode ^
      danmaku.hashCode ^
      reply.hashCode ^
      favorite.hashCode ^
      coin.hashCode ^
      share.hashCode ^
      nowRank.hashCode ^
      hisRank.hashCode ^
      like.hashCode ^
      dislike.hashCode ^
      evaluation.hashCode ^
      argueMsg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Stat &&
          runtimeType == other.runtimeType &&
          aid == other.aid &&
          view == other.view &&
          danmaku == other.danmaku &&
          reply == other.reply &&
          favorite == other.favorite &&
          coin == other.coin &&
          share == other.share &&
          nowRank == other.nowRank &&
          hisRank == other.hisRank &&
          like == other.like &&
          dislike == other.dislike &&
          evaluation == other.evaluation &&
          argueMsg == other.argueMsg;
}

class SupportFormat {
  final PlatformInt64 quality;
  final String format;
  final String newDescription;
  final String displayDesc;
  final String superscript;

  const SupportFormat({
    required this.quality,
    required this.format,
    required this.newDescription,
    required this.displayDesc,
    required this.superscript,
  });

  static Future<SupportFormat> default_() =>
      RustLib.instance.api.crateApiDataBilibiliSupportFormatDefault();

  @override
  int get hashCode =>
      quality.hashCode ^
      format.hashCode ^
      newDescription.hashCode ^
      displayDesc.hashCode ^
      superscript.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SupportFormat &&
          runtimeType == other.runtimeType &&
          quality == other.quality &&
          format == other.format &&
          newDescription == other.newDescription &&
          displayDesc == other.displayDesc &&
          superscript == other.superscript;
}

class Video {
  final PlatformInt64 id;
  final String baseUrl;
  final List<String> backupUrl;
  final List<String> backupUrl2;
  final PlatformInt64 bandwidth;
  final String mimeType;
  final String mimeType2;
  final String codecs;
  final PlatformInt64 width;
  final PlatformInt64 height;
  final String frameRate;
  final String frameRate2;
  final String sar;
  final PlatformInt64 startWithSap;
  final PlatformInt64 startWithSap2;
  final SegmentBase segmentBase;
  final PlatformInt64 codecid;

  const Video({
    required this.id,
    required this.baseUrl,
    required this.backupUrl,
    required this.backupUrl2,
    required this.bandwidth,
    required this.mimeType,
    required this.mimeType2,
    required this.codecs,
    required this.width,
    required this.height,
    required this.frameRate,
    required this.frameRate2,
    required this.sar,
    required this.startWithSap,
    required this.startWithSap2,
    required this.segmentBase,
    required this.codecid,
  });

  static Future<Video> default_() =>
      RustLib.instance.api.crateApiDataBilibiliVideoDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      baseUrl.hashCode ^
      backupUrl.hashCode ^
      backupUrl2.hashCode ^
      bandwidth.hashCode ^
      mimeType.hashCode ^
      mimeType2.hashCode ^
      codecs.hashCode ^
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      frameRate2.hashCode ^
      sar.hashCode ^
      startWithSap.hashCode ^
      startWithSap2.hashCode ^
      segmentBase.hashCode ^
      codecid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Video &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          baseUrl == other.baseUrl &&
          backupUrl == other.backupUrl &&
          backupUrl2 == other.backupUrl2 &&
          bandwidth == other.bandwidth &&
          mimeType == other.mimeType &&
          mimeType2 == other.mimeType2 &&
          codecs == other.codecs &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          frameRate2 == other.frameRate2 &&
          sar == other.sar &&
          startWithSap == other.startWithSap &&
          startWithSap2 == other.startWithSap2 &&
          segmentBase == other.segmentBase &&
          codecid == other.codecid;
}

class VideoQuality {
  final PlatformInt64 code;

  const VideoQuality({
    required this.code,
  });

  static Future<VideoQuality> default_() =>
      RustLib.instance.api.crateApiDataBilibiliVideoQualityDefault();

  @override
  int get hashCode => code.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoQuality &&
          runtimeType == other.runtimeType &&
          code == other.code;
}

class VideoUrl {
  final String from;
  final String result;
  final String message;
  final PlatformInt64 quality;
  final String format;
  final PlatformInt64 timelength;
  final String acceptFormat;
  final List<String> acceptDescription;
  final Int64List acceptQuality;
  final PlatformInt64 videoCodecid;
  final String seekParam;
  final String seekType;
  final List<Durl> durl;
  final List<SupportFormat> supportFormats;
  final Dash dash;

  const VideoUrl({
    required this.from,
    required this.result,
    required this.message,
    required this.quality,
    required this.format,
    required this.timelength,
    required this.acceptFormat,
    required this.acceptDescription,
    required this.acceptQuality,
    required this.videoCodecid,
    required this.seekParam,
    required this.seekType,
    required this.durl,
    required this.supportFormats,
    required this.dash,
  });

  static Future<VideoUrl> default_() =>
      RustLib.instance.api.crateApiDataBilibiliVideoUrlDefault();

  @override
  int get hashCode =>
      from.hashCode ^
      result.hashCode ^
      message.hashCode ^
      quality.hashCode ^
      format.hashCode ^
      timelength.hashCode ^
      acceptFormat.hashCode ^
      acceptDescription.hashCode ^
      acceptQuality.hashCode ^
      videoCodecid.hashCode ^
      seekParam.hashCode ^
      seekType.hashCode ^
      durl.hashCode ^
      supportFormats.hashCode ^
      dash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoUrl &&
          runtimeType == other.runtimeType &&
          from == other.from &&
          result == other.result &&
          message == other.message &&
          quality == other.quality &&
          format == other.format &&
          timelength == other.timelength &&
          acceptFormat == other.acceptFormat &&
          acceptDescription == other.acceptDescription &&
          acceptQuality == other.acceptQuality &&
          videoCodecid == other.videoCodecid &&
          seekParam == other.seekParam &&
          seekType == other.seekType &&
          durl == other.durl &&
          supportFormats == other.supportFormats &&
          dash == other.dash;
}
